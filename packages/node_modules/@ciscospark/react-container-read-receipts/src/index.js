import React, {Component} from 'react';
import PropTypes from 'prop-types';
import {connect} from 'react-redux';
import {bindActionCreators} from 'redux';

import classNames from 'classnames';

import {getReadReceipts} from './selectors';

import {fetchAvatarsForUsers} from '@ciscospark/redux-module-avatar';
import TypingAvatar from '@ciscospark/react-component-typing-avatar';
import Badge from '@ciscospark/react-component-badge';

import styles from './styles.css';

export class ReadReceipts extends Component {
  componentWillReceiveProps(nextProps) {
    const {users} = this.props.readReceipts;
    const nextUsers = nextProps.readReceipts.users;
    if (users !== nextUsers) {
      this.props.fetchAvatarsForUsers(nextUsers.map((user) => user.userId), this.props.sparkInstance);
    }
  }

  shouldComponentUpdate(nextProps) {
    const {props} = this;
    return nextProps.readReceipts !== props.readReceipts;
  }

  render() {
    const {users, totalCount} = this.props.readReceipts;
    const readReceipts = users.map((user) =>
      <TypingAvatar
        image={user.image}
        isTyping={user.isTyping}
        key={user.userId}
        name={user.displayName}
      />
    );
    const remainingUsers = totalCount - users.length;
    if (remainingUsers) {
      readReceipts.push(
        <Badge key={`${remainingUsers}-remaining`}>
          {`+${remainingUsers}`}
        </Badge>
      );
    }

    return (
      <div className={classNames(`ciscospark-read-receipts`, styles.readReceipts)}>
        {readReceipts}
      </div>
    );
  }
}

function mapStateToProps(state, ownProps) {
  return {
    readReceipts: getReadReceipts(state),
    sparkInstance: ownProps.sparkInstance || state.spark.get(`spark`)
  };
}

ReadReceipts.propTypes = {
  fetchAvatarsForUsers: PropTypes.func.isRequired,
  readReceipts: PropTypes.object,
  sparkInstance: PropTypes.object
};

export default connect(
  mapStateToProps,
  (dispatch) => bindActionCreators({
    fetchAvatarsForUsers
  }, dispatch)
)(ReadReceipts);
