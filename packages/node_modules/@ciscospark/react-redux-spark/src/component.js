import {Component} from 'react';
import PropTypes from 'prop-types';
import {bindActionCreators} from 'redux';
import {connect} from 'react-redux';

import {
  updateSparkStatus,
  registerDevice,
  storeSparkInstance
} from './actions';
import {
  fetchGuest
} from '@ciscospark/redux-module-altocloud-guest';

import createSpark from './spark';

const metricName = {
  SPARK_AUTHENTICATED: {
    resource: `spark`,
    event: `authentication`,
    action: `authenticated`
  },
  DEVICE_REGISTERED: {
    resource: `device`,
    event: `registration`,
    action: `registered`
  }
};

class SparkComponent extends Component {

  componentDidMount() {
    const {
      accessToken,
      account,
      metrics
    } = this.props;

    const props = this.props;
    let spark = props.spark.get(`spark`);

    // if no access token, get a guest account for provided ID
    if (!spark && !accessToken && account) {
      this.props.fetchGuest(account);
    }

    // if access token but no spark instance, create one
    if (!spark && accessToken) {
      spark = createSpark(accessToken);
      props.storeSparkInstance(spark);
    }
    // otherwise, set up listeners and register
    if (spark) {
      this.setupListeners(spark, props, metrics);
      this.setupDevice(spark, props);
    }
  }

  componentWillReceiveProps(nextProps) {
    let spark = nextProps.spark.get(`spark`);
    const accessToken = nextProps.guest.getIn([`guest`, `accessToken`]);
    const {
      metrics
    } = nextProps;

    if (!spark && accessToken) {
      spark = createSpark(accessToken);
      nextProps.storeSparkInstance(spark);
      this.setupListeners(spark, nextProps, metrics);
    }

    this.setupDevice(spark, nextProps);
  }

  shouldComponentUpdate(nextProps) {
    const props = this.props;
    return nextProps.spark !== props.spark;
  }

  setupDevice(spark, props) {
    const {
      authenticated,
      registered,
      registerError,
      registering
    } = props.spark.get(`status`).toJS();

    if (authenticated && !registered && !registering && !registerError) {
      props.registerDevice(spark);
    }
  }

  setupListeners(spark, props, metrics) {
    spark.listenToAndRun(spark, `change:canAuthorize`, () => {
      if (metrics && spark.canAuthorize) {
        metrics.sendElapsedTime(metricName.SPARK_AUTHENTICATED, spark);
      }
      props.updateSparkStatus({authenticated: spark.canAuthorize});
    });

    spark.listenToAndRun(spark, `change:isAuthenticating`, () => {
      props.updateSparkStatus({authenticating: spark.isAuthenticating});
    });

    spark.listenToAndRun(spark.internal.device, `change:registered`, () => {
      if (metrics && spark.internal.device.registered) {
        metrics.sendElapsedTime(metricName.DEVICE_REGISTERED, spark);
      }
      props.updateSparkStatus({registered: spark.internal.device.registered});
    });
  }

  render() {
    return null;
  }
}

const injectedPropTypes = {
  registerDevice: PropTypes.func,
  spark: PropTypes.object
};

// should take refresh token, interaction, openInteraction etc...
SparkComponent.propTypes = {
  accessToken: PropTypes.string,
  account: PropTypes.string,
  ...injectedPropTypes
};

export default connect(
  (state) => ({
    mercury: state.mercury,
    spark: state.spark,
    guest: state.guest
  }),
  (dispatch) => bindActionCreators({
    fetchGuest,
    updateSparkStatus,
    registerDevice,
    storeSparkInstance
  }, dispatch)
)(SparkComponent);
