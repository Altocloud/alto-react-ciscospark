import React, {Component, PropTypes} from 'react';
import {connect} from 'react-redux';
import {bindActionCreators} from 'redux';
import {intlShape, injectIntl} from 'react-intl';
import classNames from 'classnames';
import autobind from 'autobind-decorator';

import {fetchCurrentUser, fetchToUser} from '@altocloud/redux-module-user';
import {fetchAvatarForUserId} from '@ciscospark/redux-module-avatar';
import {
  listenForIncomingCalls
} from '@ciscospark/redux-module-media';
import TitleBar from '@ciscospark/react-component-title-bar';
import Notifications from '@ciscospark/react-container-notifications';
import LoadingScreen from '@ciscospark/react-component-loading-screen';
import {ConnectedMeetComponent} from '@altocloud/widget-meet';
import {injectSpark} from '@altocloud/react-redux-spark';

import {
  setActivityMenuVisible,
  setActivityMeet,
  setActivityMessage,
  ACTIVITY_TYPE_MEET
} from './actions';
import styles from './styles.css';
import messages from './messages';

export const INITIAL_ACTIVITY_TYPE_MEET = `meet`;
export const INITIAL_ACTIVITY_TYPE_MESSAGE = `message`;

/**
 * WidgetCustomerVideo Component
 */
export class WidgetCustomerVideo extends Component {

  componentWillMount() {
    this.props.setActivityMeet();
  }

  componentWillReceiveProps(nextProps) {
    const {
      user,
      spark,
      sparkState,
      mercury,
      interaction,
      openInteraction,
      updateInteraction,
      toPersonEmail,
      toPersonId
    } = nextProps;

    const {
      authenticated,
      registered
    } = sparkState;

    const connected = mercury.getIn([`status`, `connected`]);

    if (spark && connected && authenticated && registered) {
      // handle fetching user and opening interactions
      if (!user.get(`currentUser`) && !user.getIn([`status`, `isFetchingCurrentUser`])) {
        nextProps.fetchCurrentUser(spark, (data) => {
          if (interaction && interaction.id && updateInteraction && openInteraction) {
            updateInteraction(interaction.id, {
              provider: {
                type: `spark`,
                sid: data.id
              }
            }).then(() => openInteraction(interaction));
          }
        });
      }

      if (!user.get(`toUser`) && !user.getIn([`status`, `isFetchingToUser`])) {
        nextProps.fetchToUser({toPersonEmail, toPersonId}, spark);
      }

      nextProps.listenForIncomingCalls(spark, `any`, this.handleEvent);
    }
  }

  shouldComponentUpdate(nextProps) {
    const props = this.props;

    return nextProps.mercury.getIn([`status`, `connected`]) !== props.mercury.getIn([`status`, `connected`])
      || nextProps.media.get(`callStartTime`) !== props.media.get(`callStartTime`)
      || nextProps.user !== props.user
      || nextProps.conversation !== props.conversation
      || nextProps.avatar !== props.avatar
      || nextProps.indicators !== props.indicators
      || nextProps.widgetMessageMeet !== props.widgetMessageMeet;
  }

  componentWillUnmount() {
    this.props.spark.mercury.disconnect().then(() => this.props.removeWidget());
  }

  @autobind
  handleEvent(name, data) {
    const {spark} = this.props;
    const toPersonEmail = data.actor.email;
    const toPersonId = data.actor.id;
    this.props.fetchToUser({toPersonEmail, toPersonId}, spark);
    this.props.fetchAvatarForUserId(toPersonId, spark);
    this.props.onEvent(name, data);
  }

  /**
   * Render
   *
   * @returns {Object}
   */
  render() {
    const props = this.props;
    const {
      avatar,
      toPersonEmail,
      spark,
      user,
      widgetMessageMeet
    } = props;
    const {formatMessage} = this.props.intl;

    const toUser = user.get(`toUser`);
    const showMeet = widgetMessageMeet.get(`activityType`) === ACTIVITY_TYPE_MEET;
    const loadingMessage = spark ? `Connected to Cisco Spark, please wait...` : formatMessage(messages.loadingMessage);

    // Don't load widgets until we have spark loaded and info on the toUser
    if (spark && toUser && toUser.id) {
      const toUserAvatarUrl = avatar.getIn([`items`, toUser.id]);
      return (
        <div className={classNames(`widget-message-meet`, styles.widgetMessageMeet)}>
          <div className={classNames(`banner`, styles.banner)} />
          <div className={classNames(`widget-message-meet-inner`, styles.widgetMessageMeetInner)}>
            <div className={classNames(`title-bar-wrapper`, styles.titleBarWrapper)}>
              <TitleBar
                hasMenu
                image={toUserAvatarUrl}
                name={toUser.displayName}
              />
            </div>
            {
              showMeet &&
              <ConnectedMeetComponent
                onEvent={this.handleEvent}
                shouldStartMeeting={!!toPersonEmail}
                spark={spark}
                toPersonAvatar={toUserAvatarUrl}
                toPersonId={toUser.id}
                toPersonName={toUser.displayName}
                user={user}
              />
            }
            <Notifications />
          </div>
        </div>
      );
    }
    return (
      <div className={classNames(`widget-message-meet`, styles.widgetMessageMeet)}>
        <LoadingScreen loadingMessage={loadingMessage} />
      </div>
    );
  }
}

const injectedPropTypes = {
  conversation: PropTypes.object.isRequired,
  fetchCurrentUser: PropTypes.func.isRequired,
  fetchToUser: PropTypes.func.isRequired,
  listenForIncomingCalls: PropTypes.func.isRequired,
  media: PropTypes.object.isRequired,
  setActivityMenuVisible: PropTypes.func.isRequired,
  spark: PropTypes.object,
  sparkState: PropTypes.object.isRequired,
  user: PropTypes.object.isRequired
};

WidgetCustomerVideo.propTypes = {
  closeInteraction: PropTypes.func,
  initialActivity: PropTypes.string,
  interaction: PropTypes.object,
  intl: intlShape.isRequired,
  openInteraction: PropTypes.func,
  toPersonEmail: PropTypes.string,
  toPersonId: PropTypes.string,
  updateInteraction: PropTypes.func,
  ...injectedPropTypes
};

function mapStateToProps(state) {
  return {
    avatar: state.avatar,
    conversation: state.conversation,
    media: state.media,
    spark: state.spark.get(`spark`),
    sparkState: state.spark.get(`status`).toJS(),
    mercury: state.mercury,
    user: state.user,
    indicators: state.indicators,
    widgetMessageMeet: state.widgetMessageMeet
  };
}

export default connect(
  mapStateToProps,
  (dispatch) => bindActionCreators({
    fetchAvatarForUserId,
    fetchCurrentUser,
    fetchToUser,
    listenForIncomingCalls,
    setActivityMeet,
    setActivityMessage,
    setActivityMenuVisible
  }, dispatch)
)(injectIntl(injectSpark(WidgetCustomerVideo)));
